#!/usr/bin/env bash

# WildlifeSystems - sensor read (parallel)
#
# Parallelised variant of `sr`. This runs per-sensor scripts concurrently,
# captures their stdout to temporary files, appends stderr to per-sensor
# logfiles under ${LOG_DIR}, then injects node and timestamp and merges
# results with jq in a single invocation.

set -u
set -o pipefail

readonly REQUIRED_CMDS=(jq timeout find basename sed awk pi-data mktemp)

missing=()
for _cmd in "${REQUIRED_CMDS[@]}"; do
  if ! command -v "$_cmd" >/dev/null 2>&1; then
    missing+=("$_cmd")
  fi
done
if (( ${#missing[@]} )); then
  printf 'Missing required commands: %s\n' "${missing[*]}" >&2
  exit 1
fi

if [[ $# -eq 0 ]]; then
  printf 'No arguments supplied\n' >&2
  exit 2
fi

SELF="${BASH_SOURCE[0]:-$0}"
if [[ "${SELF}" != /* ]]; then
  if command -v "$(basename "${SELF}")" >/dev/null 2>&1; then
    SELF=$(command -v "$(basename "${SELF}")")
  else
    SELF="$(pwd)/${SELF}"
  fi
fi

SCRIPT="$1"
DEV=${2:-all}

readonly LOG_DIR=/var/log/sensor-control
readonly SENS_DIR=/usr/bin
readonly TIMEOUT_SECS=5
readonly KILL_AFTER=5s

mkdir -p "${LOG_DIR}" 2>/dev/null || true

PI_SERIAL=$(pi-data serial)
TSTAMP=$(date +%s)

run_list() {
  find "${SENS_DIR}" -name 'sensor-*' -executable -print0 |
    while IFS= read -r -d '' SENS_SCRIPT; do
      "${SENS_SCRIPT}" identify
      rc=$?
      if [[ $rc -eq 60 ]]; then
        SCRIPT_NAME=$(basename "${SENS_SCRIPT}")
        printf '%s\n' "${SCRIPT_NAME#sensor-}"
      fi
    done
}

if [[ "${SCRIPT}" == "list" ]]; then
  run_list
  exit 0
fi

# Default concurrency: from environment or CPU count, fall back to 4
CONCURRENCY=${CONCURRENCY:-$(nproc 2>/dev/null || getconf _NPROCESSORS_ONLN 2>/dev/null || echo 4)}
if ! [[ "${CONCURRENCY}" =~ ^[0-9]+$ ]] || [[ ${CONCURRENCY} -lt 1 ]]; then
  CONCURRENCY=4
fi

if [[ "${SCRIPT}" == "all" ]]; then
  # Use bash coprocesses to capture stdout in memory without temp files.
  declare -a SENSOR_NAMES=()
  declare -a COPROC_PIDS=()
  declare -a COPROC_FDS=()
  declare -a COPROC_NAMES=()
  declare -a ALL_JSONS=()

  i=0
  while IFS= read -r SENSOR_NAME; do
    SENSOR_NAMES+=("${SENSOR_NAME}")
    DEV=all
    SENS_SCRIPT="${SENS_DIR}/sensor-${SENSOR_NAME}"
    LOGFILE="${LOG_DIR}/${SENSOR_NAME}.log"

    # Use a unique coproc name to avoid reusing older coproc variables
    name="COPROC_${i}_$$"
    # Ensure any remnants are removed
    unset "${name}" "${name}_PID" 2>/dev/null || true

    # Start named coprocess; its stdout is available via the coproc array's index 0
    eval "coproc ${name} { timeout --signal=TERM --kill-after=${KILL_AFTER} ${TIMEOUT_SECS} \"${SENS_SCRIPT}\" \"${DEV}\" 2>>\"${LOGFILE}\"; }"

    # Acquire PID and FD using indirect expansion and a nameref
    pid_var="${name}_PID"
    pid=${!pid_var:-}
    declare -n copref="${name}"
    fd=${copref[0]:-}

    COPROC_PIDS+=("${pid}")
    COPROC_FDS+=("${fd}")
    COPROC_NAMES+=("${name}")

    ((i++))

    # Throttle concurrency: wait for the oldest job when limit reached
    while (( ${#COPROC_PIDS[@]} >= CONCURRENCY )); do
      pid_to_wait=${COPROC_PIDS[0]}
      wait "${pid_to_wait}" || true
      rc=$?

      fd_to_read=${COPROC_FDS[0]}
      SENS_JSON=""
      # Verify fd is numeric and currently open by checking /proc
      if [[ -n "${fd_to_read}" ]] && [[ -e "/proc/$$/fd/${fd_to_read}" ]]; then
        SENS_JSON=$(cat <&"${fd_to_read}" 2>/dev/null || true)
        # Close the fd
        eval "exec ${fd_to_read}<&-" || true
      fi

      # Unset coproc variables for the processed coproc to avoid lingering entries
      old_name=${COPROC_NAMES[0]:-}
      if [[ -n "${old_name}" ]]; then
        unset "${old_name}" "${old_name}_PID" 2>/dev/null || true
      fi
      # Shift arrays (remove first element)
      COPROC_PIDS=("${COPROC_PIDS[@]:1}")
      COPROC_FDS=("${COPROC_FDS[@]:1}")
      COPROC_NAMES=("${COPROC_NAMES[@]:1}")
      sensor_proc_name=${SENSOR_NAMES[0]}
      SENSOR_NAMES=("${SENSOR_NAMES[@]:1}")

      # If job succeeded, inject and store; else skip
      if [[ ${rc} -eq 0 ]] && [[ -n "${SENS_JSON}" ]]; then
        SENS_JSON=$(jq -c --arg node "${PI_SERIAL}" --argjson ts "${TSTAMP}" 'map(.node_id = $node | .timestamp = $ts)' <<<"${SENS_JSON}")
        ALL_JSONS+=("${SENS_JSON}")
      fi
    done
  done < <(run_list)

  # Wait for and process remaining coprocesses in order
  for idx in "${!COPROC_PIDS[@]}"; do
    pid=${COPROC_PIDS[idx]}
    fd=${COPROC_FDS[idx]}
    name=${COPROC_NAMES[idx]:-}
    wait "${pid}" || true
    rc=$?
    SENS_JSON=""
    if [[ -n "${fd}" ]] && [[ -e "/proc/$$/fd/${fd}" ]]; then
      SENS_JSON=$(cat <&"${fd}" 2>/dev/null || true)
      eval "exec ${fd}<&-" || true
    fi
    # Unset coproc variables for this coproc
    if [[ -n "${name}" ]]; then
      unset "${name}" "${name}_PID" 2>/dev/null || true
    fi
    if [[ ${rc} -eq 0 ]] && [[ -n "${SENS_JSON}" ]]; then
      SENS_JSON=$(jq -c --arg node "${PI_SERIAL}" --argjson ts "${TSTAMP}" 'map(.node_id = $node | .timestamp = $ts)' <<<"${SENS_JSON}")
      ALL_JSONS+=("${SENS_JSON}")
    fi
  done

  if (( ${#ALL_JSONS[@]} == 0 )); then
    printf '[]\n'
    exit 0
  fi

  printf '%s\n' "${ALL_JSONS[@]}" | jq -s 'add' -c
  exit 0
fi

if [[ "${SCRIPT}" == "external" ]]; then
  "${SELF}" all | jq -c 'del(.[] | select(.internal == true))'
  exit 0
fi

if [[ "${SCRIPT}" == "internal" ]]; then
  "${SELF}" all | jq -c 'del(.[] | select(.internal == false))'
  exit 0
fi

# Single sensor invocation (non-parallel)
SENS_SCRIPT="${SENS_DIR}/sensor-${SCRIPT}"
if [[ "${DEV}" == "list" ]]; then
  "${SENS_SCRIPT}" list
  exit 0
fi

SENSOR_BASENAME=$(basename "${SENS_SCRIPT}")
SENS_LOG="${LOG_DIR}/${SENSOR_BASENAME}.log"
rc=0
SENS_JSON=$(timeout --signal=TERM --kill-after=${KILL_AFTER} ${TIMEOUT_SECS} "${SENS_SCRIPT}" "${DEV}" 2>>"${SENS_LOG}") || rc=$?
rc=${rc:-0}

if [[ $rc -ne 0 ]]; then
  if [[ $rc -eq 20 ]]; then
    printf 'Unknown device\n'
  elif [[ $rc -eq 21 ]]; then
    printf 'Unknown sensor\n'
  fi
  exit "$rc"
fi

jq -c --arg node "${PI_SERIAL}" --argjson ts "${TSTAMP}" 'map(.node_id = $node | .timestamp = $ts)' <<<"${SENS_JSON}"

exit 0
